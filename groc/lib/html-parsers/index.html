<!DOCTYPE html><html lang="en"><head><title>lib\html-parsers\index</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../../"><meta name="groc-document-path" content="lib\html-parsers\index"><meta name="groc-project-path" content="lib\html-parsers\index.js"><link rel="stylesheet" type="text/css" media="all" href="../../assets/style.css"><script type="text/javascript" src="../../assets/behavior.js"></script><body><div id="meta"><div class="file-path">lib\html-parsers\index.js</div></div><div id="document"><div class="segment"><div class="code"><div class="wrapper"><span class="hljs-pi">'use strict'</span>

<span class="hljs-keyword">import</span> config <span class="hljs-keyword">from</span> <span class="hljs-string">'config'</span>
<span class="hljs-keyword">import</span> http <span class="hljs-keyword">from</span> <span class="hljs-string">'http'</span>
<span class="hljs-keyword">import</span> https <span class="hljs-keyword">from</span> <span class="hljs-string">'https'</span>
<span class="hljs-keyword">import</span> querystring <span class="hljs-keyword">from</span> <span class="hljs-string">'querystring'</span>
<span class="hljs-keyword">import</span> zlib <span class="hljs-keyword">from</span> <span class="hljs-string">'zlib'</span>
<span class="hljs-keyword">import</span> { notFound200, codeKo200 } <span class="hljs-keyword">from</span> <span class="hljs-string">'./false-error-codes'</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Helper to send an HTTP request to Myfox services, and parse response stream.
You will use this to analyze Myfox HTML response from an HTTP query,
and to avoid parsing general events like errors, authentication problems, etc...</p>
<p>Parameters:</p>
<ul>
<li><p><strong>method must be a string.</strong><br/>(The HTTP method, in upper case (GET, POST, PUT, PATCH, DELETE, ...))</p>
</li>
<li><p><strong>path must be a string.</strong><br/>(The URL path part (without query string and host parts), like &#39;/home/1234&#39;)</p>
</li>
<li><p><strong>streamParser must be an object.</strong><br/>(a stream parser to pipe on the distant response stream)</p>
</li>
<li><p><strong>callback must be a function.</strong><br/>(The callback function to call after parsing (will take (err, data) as arguments))</p>
</li>
<li><p><strong>queryParams must be an object.</strong><br/>(An object to serialize into the query string)</p>
</li>
<li><p><strong>payload must be an object.</strong><br/>(An object to serialize as the request payload)</p>
</li>
<li><p><strong>headers must be an object.</strong><br/>(An object to push into the request headers)</p>
</li>
<li><p><strong>cookieJar must be a function.</strong><br/>(The function that will get/set the data to keep between each query (mainly the Cookie))</p>
</li>
</ul></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">httpsRequest</span> (<span class="hljs-params">method, path, streamParser, callback, queryParams, payload, headers, cookieJar</span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>POST / PUT / PATCH cases</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">if</span> (payload) {
    payload = querystring.stringify(payload) <span class="hljs-comment">// encoded as querystring for login needs.</span>
  }
  <span class="hljs-keyword">const</span> postHeaders = (payload &amp;&amp; (method === <span class="hljs-string">'POST'</span> || method === <span class="hljs-string">'PUT'</span> || method === <span class="hljs-string">'PATCH'</span>)) ? {
    <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/x-www-form-urlencoded; charset=UTF-8'</span>,
    <span class="hljs-string">'Content-Length'</span>: payload.length
  } : {}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Query parameters to path</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">if</span> (queryParams &amp;&amp; queryParams.constructor === <span class="hljs-built_in">Object</span> &amp;&amp; <span class="hljs-built_in">Object</span>.keys(queryParams).length &gt; <span class="hljs-number">0</span>) {
    queryParams = querystring.stringify(queryParams)
    path = path + <span class="hljs-string">'?'</span> + queryParams
  }

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">let</span> cookie = (cookieJar !== <span class="hljs-literal">null</span> &amp;&amp; cookieJar !== <span class="hljs-literal">undefined</span> &amp;&amp; cookieJar().cookie !== <span class="hljs-literal">undefined</span>) ? {<span class="hljs-string">'cookie'</span>: [cookieJar().cookie]} : {}
    <span class="hljs-keyword">let</span> requestData = {
      hostname: config.get(<span class="hljs-string">'html.myfox.hostname'</span>),
      port: config.get(<span class="hljs-string">'html.myfox.port'</span>),
      path: path,
      headers: <span class="hljs-built_in">Object</span>.assign(postHeaders, config.get(<span class="hljs-string">'html.myfox.headers'</span>), cookie, headers),
      method: method
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>console.log(&#39;Sending request to Myfox:&#39;, requestData)</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">let</span> req = ((config.get(<span class="hljs-string">'html.myfox.protocol'</span>) === <span class="hljs-string">'http'</span>) ? http : https).request(requestData, (res) =&gt; {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>console.log(&#39;Receiving response:&#39;, res.statusCode, res.headers)
If HTTP error case, no need to parse the body</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> (res.statusCode &gt;= <span class="hljs-number">400</span>) {
        <span class="hljs-keyword">const</span> error = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Error status code returned by Myfox.'</span>)
        error.status = res.statusCode
        <span class="hljs-keyword">return</span> callback(error)
      }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If false HTTP codes, fix them</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> (res.statusCode === <span class="hljs-number">302</span> &amp;&amp; res.headers.location === config.get(<span class="hljs-string">'html.myfox.redirectForbidden'</span>)) {
        <span class="hljs-keyword">const</span> error = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Myfox redirected to / because of forbidden access.'</span>)
        error.status = <span class="hljs-number">403</span>
        <span class="hljs-keyword">return</span> callback(error)
      }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>get Set-Cookie response header value to use it later</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">let</span> setCookie = res.headers[<span class="hljs-string">'set-cookie'</span>]
      <span class="hljs-keyword">if</span> (setCookie !== <span class="hljs-literal">null</span> &amp;&amp; cookieJar !== <span class="hljs-literal">null</span> &amp;&amp; cookieJar !== <span class="hljs-literal">undefined</span>) {
        cookieJar({<span class="hljs-string">'cookie'</span>: setCookie[<span class="hljs-number">0</span>].replace(<span class="hljs-regexp">/ ?expires=[^;]*;/</span>, <span class="hljs-string">''</span>).replace(<span class="hljs-regexp">/ ?path=\//</span>, <span class="hljs-string">''</span>).trim()})
      }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>From here we need body data. Sometimes it can be zipped!</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">let</span> unzippedRes
      <span class="hljs-keyword">let</span> encoding = res.headers[<span class="hljs-string">'content-encoding'</span>]
      <span class="hljs-keyword">if</span> (encoding === <span class="hljs-string">'gzip'</span>) {
        unzippedRes = res.pipe(zlib.createGunzip())
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (encoding === <span class="hljs-string">'deflate'</span>) {
        unzippedRes = res.pipe(zlib.createInflate())
      } <span class="hljs-keyword">else</span> {
        unzippedRes = res
      }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>From here we start to analyze the content of the data. Keep it in a buffer anyway.</p></div></div><div class="code"><div class="wrapper">      unzippedRes.setEncoding(<span class="hljs-string">'utf8'</span>)
      <span class="hljs-keyword">let</span> buffer = <span class="hljs-string">''</span>
      unzippedRes.on(<span class="hljs-string">'data'</span>, (chunk) =&gt; {
        buffer += chunk
      })

      <span class="hljs-keyword">let</span> notFound200Instance = notFound200()
      unzippedRes.pipe(notFound200Instance) <span class="hljs-comment">// Change 'Page not found' code 200 by 404</span>
      notFound200Instance.on(<span class="hljs-string">'error'</span>, callback)

      <span class="hljs-keyword">let</span> codeKo200Instance = codeKo200()
      unzippedRes.pipe(codeKo200Instance) <span class="hljs-comment">// Change code KO with 200 by 400 and fetch the message</span>
      codeKo200Instance.on(<span class="hljs-string">'error'</span>, (err) =&gt; {
        <span class="hljs-keyword">if</span> (err.status === <span class="hljs-number">400</span>) {
          callback(err, <span class="hljs-literal">null</span>)
        } <span class="hljs-comment">// else it's not JSON data!</span>
      })

      <span class="hljs-keyword">if</span> (streamParser !== <span class="hljs-literal">null</span> &amp;&amp; streamParser !== <span class="hljs-literal">undefined</span>) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>There is a streamParser. &#39;end&#39; event is plugged on streamParser, not unzippedRes.</p></div></div><div class="code"><div class="wrapper">        unzippedRes.pipe(streamParser)
        streamParser.on(<span class="hljs-string">'end'</span>, () =&gt; {
          callback(<span class="hljs-literal">null</span>, streamParser)
        })
      } <span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>There is no streamParser, so all bufferized data will be returned at the &#39;end&#39; event.</p></div></div><div class="code"><div class="wrapper">        unzippedRes.on(<span class="hljs-string">'end'</span>, () =&gt; {
          callback(<span class="hljs-literal">null</span>, buffer)
        })
      }
    })

    <span class="hljs-keyword">if</span> (streamParser !== <span class="hljs-literal">null</span> &amp;&amp; streamParser !== <span class="hljs-literal">undefined</span>) {
      streamParser.on(<span class="hljs-string">'error'</span>, callback)
    }
    req.on(<span class="hljs-string">'error'</span>, callback)

    <span class="hljs-keyword">if</span> (payload &amp;&amp; (method === <span class="hljs-string">'POST'</span> || method === <span class="hljs-string">'PUT'</span> || method === <span class="hljs-string">'PATCH'</span>)) {
      req.write(payload)
    }
    req.end()
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'requestData() encounter exception parsing Myfox response.'</span>, err)
    <span class="hljs-keyword">if</span> (err.status === <span class="hljs-literal">null</span> || err.status === <span class="hljs-literal">undefined</span>) {
      err.status = <span class="hljs-number">500</span>
    }
    <span class="hljs-keyword">return</span> callback(err)
  }
}</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Returns a function to generate a stream parser for a given HTML element, passed to the given callback.</p>
<p>Parameters:</p>
<ul>
<li><strong>callback must be a function.</strong><br/>(The callback function to give to the inner text stream parser.)</li>
</ul>
<p><strong>Returns a Function</strong><br/>(A function generating a stream parser to retrieve inner text.)</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trumpetInnerText</span> (<span class="hljs-params">callback</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>{
    <span class="hljs-keyword">let</span> buffer = <span class="hljs-string">''</span>
    <span class="hljs-keyword">const</span> stream = element.createReadStream()
    stream.setEncoding(<span class="hljs-string">'utf8'</span>)
    stream.on(<span class="hljs-string">'data'</span>, (chunk) =&gt; {
      buffer += chunk
    })
    stream.on(<span class="hljs-string">'end'</span>, () =&gt; {
      callback(buffer)
    })
    stream.on(<span class="hljs-string">'error'</span>, (err) =&gt; {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(err)
    })
  }
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>TODO !0: doc et TU</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trumpetClasses</span> (<span class="hljs-params">callback</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>{
    element.getAttribute(<span class="hljs-string">'class'</span>, (classes) =&gt; {
      callback(classes.split(<span class="hljs-string">' '</span>))
    })
  }
}</div></div></div></div></body></html>