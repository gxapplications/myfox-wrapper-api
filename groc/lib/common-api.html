<!DOCTYPE html><html lang="en"><head><title>lib\common-api</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="lib\common-api"><meta name="groc-project-path" content="lib\common-api.js"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path">lib\common-api.js</div></div><div id="document"><div class="segment"><div class="code"><div class="wrapper"><span class="hljs-pi">'use strict'</span>

<span class="hljs-keyword">import</span> Joi <span class="hljs-keyword">from</span> <span class="hljs-string">'joi'</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Method _notImplemented</span></p>
<p>Uses the fallback API wrapper if available, else raises a &#39;Not Implemented&#39; exception.
Keep this function private: Not exported with the class.
As we use &#39;this&#39; in the function, you MUST always call it with a bind:
_notImplemented.bind(<object_as_this>)(...)</p>
<p>Parameters:</p>
<ul>
<li><p><strong>functionName must be a string.</strong><br/>(The method name that is not implemented yet.)</p>
</li>
<li><p><strong>params must be a mixed.</strong><br/>(The list of the parameters given to the original method (rest notation).)</p>
</li>
</ul>
<p><strong>Can throw an Error</strong><br/>(If there is no fallback API set during the API wrapper instanciation.)</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> _notImplemented = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">functionName, ...params</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.fallbackApi !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.fallbackApi !== <span class="hljs-literal">undefined</span>) {
    <span class="hljs-keyword">this</span>.fallbackApi[functionName](params)
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Feature not implemented in this wrapper.'</span>)
  }
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Parent class that contains the method list to implement on the subclasses, and common methods.
The constructor must never be squizzed even by a subclass: parameters validation is done here.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyfoxWrapperApiCommon</span> </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Construction parts</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>TODO: DOC</p></div></div><div class="code"><div class="wrapper">  constructor (options, fallbackApi, accountCredentials) {
    <span class="hljs-keyword">this</span>.options = <span class="hljs-built_in">Object</span>.assign({}, MyfoxWrapperApiCommon.defaultOptions(), options)
    Joi.assert(<span class="hljs-keyword">this</span>.options, MyfoxWrapperApiCommon.optionsSchema())

    <span class="hljs-keyword">this</span>.accountCredentials = accountCredentials
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.accountCredentials !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.accountCredentials !== <span class="hljs-literal">undefined</span>) {
      Joi.assert(<span class="hljs-keyword">this</span>.accountCredentials, MyfoxWrapperApiCommon.accountCredentialsSchema())
    }

    <span class="hljs-keyword">this</span>.fallbackApi = fallbackApi

    <span class="hljs-keyword">this</span>.authenticatedUntil = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()
    <span class="hljs-keyword">this</span>.authenticatedData = <span class="hljs-literal">null</span>
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>TODO: DOC</p></div></div><div class="code"><div class="wrapper">  static defaultOptions () {
    <span class="hljs-keyword">return</span> {
      apiStrategy: <span class="hljs-string">'custom'</span>,
      autoAuthentication: <span class="hljs-literal">true</span>,
      autoAuthRetryCredits: <span class="hljs-number">1</span>, <span class="hljs-comment">// 2 calls maximum means 1 retry</span>
      authValidity: <span class="hljs-number">120</span>, <span class="hljs-comment">// 2 minutes</span>
      myfoxSiteIds: [] <span class="hljs-comment">// must be overriden by your siteIds (most often just one...)</span>
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>TODO: DOC</p></div></div><div class="code"><div class="wrapper">  static optionsSchema () {
    <span class="hljs-keyword">return</span> Joi.object({
      apiStrategy: Joi.string().required().valid([<span class="hljs-string">'htmlOnly'</span>, <span class="hljs-string">'htmlFirst'</span>, <span class="hljs-string">'restFirst'</span>, <span class="hljs-string">'restOnly'</span>, <span class="hljs-string">'custom'</span>]),
      autoAuthentication: Joi.boolean().required(),
      autoAuthRetryCredits: Joi.number().integer().min(<span class="hljs-number">0</span>).max(<span class="hljs-number">10</span>).required(),
      authValidity: Joi.number().integer().min(<span class="hljs-number">1</span>).max(<span class="hljs-number">86400</span>).required(), <span class="hljs-comment">// 10 seconds to 24hrs</span>
      myfoxSiteIds: Joi.array().items(Joi.number().integer().min(<span class="hljs-number">1</span>)).min(<span class="hljs-number">1</span>).required() <span class="hljs-comment">// at least 1 number</span>
    })
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>TODO: DOC</p></div></div><div class="code"><div class="wrapper">  static accountCredentialsSchema () {
    <span class="hljs-keyword">return</span> Joi.object({
      username: Joi.string().required(),
      password: Joi.string().required()
    })
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>MyFox distant caller and auto-authentification system</p></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Method callApi</span></p>
<p>Call this when you need to call distant Myfox services.
This method will manage authentication layer.</p>
<p>Parameters:</p>
<ul>
<li><p><strong>url must be a string.</strong><br/>(The HTTP(s) URL to call)</p>
</li>
<li><p><strong>method must be a string.</strong><br/>(The HTTP method in uppercase (GET, POST, PATCH, PUT, DELETE, etc...))</p>
</li>
<li><p><strong>streamParser must be an object.</strong><br/>(A stream parser to pipe on the distant response stream)</p>
</li>
<li><p><strong>queryParams must be an object.</strong><br/>(An object to serialize into the query string)</p>
</li>
<li><p><strong>headers must be an object.</strong><br/>(An object to push into the request headers)</p>
</li>
<li><p><strong>payload must be an object.</strong><br/>(An object to serialize as the request payload)</p>
</li>
</ul>
<p><strong>Returns a Promise</strong><br/>(A promise for asynchronous behavior)</p></div></div><div class="code"><div class="wrapper">  callApi (url, method, streamParser, queryParams, headers, payload) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>No auth needed, handled manually. Just call the service.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.autoAuthentication === <span class="hljs-literal">false</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((resolve, reject) =&gt; {
        <span class="hljs-keyword">this</span>.callDistant(url, method, queryParams, headers, payload, streamParser, resolve, reject, <span class="hljs-literal">null</span>)
      })
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Try to authenticate function</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">let</span> tryToAuthenticate
    tryToAuthenticate = (retryCredits, callDistant, streamParser, resolve, reject) =&gt; {
      <span class="hljs-keyword">this</span>.authenticate(<span class="hljs-keyword">this</span>.authenticatedData, (err, authData) =&gt; {
        <span class="hljs-keyword">if</span> (err) {
          <span class="hljs-keyword">if</span> (retryCredits &gt; <span class="hljs-number">0</span>) { <span class="hljs-comment">// retry one more time</span>
            <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">'Authentication failed. Retrying '</span> + retryCredits + <span class="hljs-string">' times left.'</span>)
            <span class="hljs-keyword">return</span> tryToAuthenticate(retryCredits - <span class="hljs-number">1</span>, callDistant, streamParser, resolve, reject)
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">'Authentication failed. No retry credits left.'</span>)
            <span class="hljs-keyword">const</span> error = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Authentication failed.'</span>)
            error.status = <span class="hljs-number">403</span>
            error.previous = err
            <span class="hljs-keyword">return</span> reject(error)
          }
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">this</span>.authenticatedUntil.setTime(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime() + (<span class="hljs-keyword">this</span>.options.authValidity * <span class="hljs-number">1000</span>))
          <span class="hljs-keyword">this</span>.authenticatedData = authData
          <span class="hljs-keyword">return</span> callDistant(url, method, queryParams, headers, payload, streamParser, resolve, reject, <span class="hljs-literal">null</span>)
        }
      })
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((resolve, reject) =&gt; {
      <span class="hljs-keyword">let</span> authCredits = <span class="hljs-keyword">this</span>.options.autoAuthRetryCredits</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>For sure, we need to auth before calling service</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isMaybeAuthenticated()) {
        tryToAuthenticate(authCredits, <span class="hljs-keyword">this</span>.callDistant.bind(<span class="hljs-keyword">this</span>), streamParser, resolve, reject)
      } <span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Maybe we are still authenticated. Try service and see... if fails auth and try again once.</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">this</span>.callDistant(url, method, queryParams, headers, payload, streamParser, resolve, reject, () =&gt; {
          tryToAuthenticate(authCredits, <span class="hljs-keyword">this</span>.callDistant.bind(<span class="hljs-keyword">this</span>), streamParser, resolve, reject)
        })
      }
    })
  }

  isMaybeAuthenticated () {
    <span class="hljs-keyword">const</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.authenticatedUntil &gt; now
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Wrapper API methods</p></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Call Myfox authentication process.
This method must be overridden in the extended api implementation.</p>
<p>Parameters:</p>
<ul>
<li><p><strong>authData must be an object.</strong><br/>(Authentication data that comes from previous authentication.)</p>
</li>
<li><p><strong>callback must be a function.</strong><br/>(To use when the authentication is done (fail or success), with parameters: (err, authData))</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">  authenticate (authData, callback) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Feature not implemented in this wrapper.'</span>)
  }</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Call Myfox interface with the action/query.
This method must be overridden in the extended api implementation.
Do not use this method directly to call Myfox services. Prefer use this.callApi(url, method, queryParams, headers, payload)</p>
<p>Parameters:</p>
<ul>
<li><p><strong>url must be a string.</strong><br/>(The HTTP(s) URL to call)</p>
</li>
<li><p><strong>method must be a string.</strong><br/>(The HTTP method in uppercase (GET, POST, PATCH, PUT, DELETE, etc...))</p>
</li>
<li><p><strong>queryParams must be an object.</strong><br/>(An object to serialize into the query string)</p>
</li>
<li><p><strong>headers must be an object.</strong><br/>(An object to push into the request headers)</p>
</li>
<li><p><strong>payload must be an object.</strong><br/>(An object to serialize as the request payload)</p>
</li>
<li><p><strong>streamParser must be an object.</strong><br/>(A stream parser to pipe on the distant response stream)</p>
</li>
<li><p><strong>resolve must be a function.</strong><br/>(The callback to use if the call succeeds (with data as unique parameter))</p>
</li>
<li><p><strong>reject must be a function.</strong><br/>(The callback to use if the call fails (with the error as unique parameter))</p>
</li>
<li><p><strong>reAuthenticate must be a function.</strong><br/>(The callback to use if the call received a 403 error, to force a new loop with an authentication process. May be null ! In this case, throw an error.)</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">  callDistant (url, method, queryParams, headers, payload, streamParser, resolve, reject, reAuthenticate) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Feature not implemented in this wrapper.'</span>)
  }

  callHome (callback) {
    _notImplemented.bind(<span class="hljs-keyword">this</span>)(<span class="hljs-string">'callHome'</span>, callback)
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> MyfoxWrapperApiCommon</div></div></div></div></body></html>