<!DOCTYPE html><html lang="en"><head><title>lib/common-api</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="lib/common-api"><meta name="groc-project-path" content="lib/common-api.js"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path">lib/common-api.js</div></div><div id="document"><div class="segment"><div class="code"><div class="wrapper"><span class="hljs-pi">'use strict'</span>

<span class="hljs-keyword">import</span> Joi <span class="hljs-keyword">from</span> <span class="hljs-string">'joi'</span>

<span class="hljs-keyword">import</span> persistentState <span class="hljs-keyword">from</span> <span class="hljs-string">'./persistent-state'</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Method _notImplemented</span></p>
<p>Uses the fallback API wrapper if available, else raises a &#39;Not Implemented&#39; exception.
Keep this function private: Not exported with the class.
As we use &#39;this&#39; in the function, you MUST always call it with a bind:
_notImplemented.bind(<object_as_this>)(...)</p>
<p>Parameters:</p>
<ul>
<li><p><strong>functionName must be a string.</strong><br/>(The method name that is not implemented yet.)</p>
</li>
<li><p><strong>params must be a mixed.</strong><br/>(The list of the parameters given to the original method (rest notation).)</p>
</li>
</ul>
<p><strong>Can throw an Error</strong><br/>(If there is no fallback API set during the API wrapper instanciation.)</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> _notImplemented = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">functionName, ...params</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.fallbackApi !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.fallbackApi !== <span class="hljs-literal">undefined</span>) {
    <span class="hljs-keyword">this</span>.fallbackApi[functionName](params)
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Feature not implemented in this wrapper.'</span>)
  }
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Parent class that contains the method list to implement on the subclasses, and common methods.
The constructor must never be squizzed even by a subclass: parameters validation is done here.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyfoxWrapperApiCommon</span> </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Construction parts</p></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Common constructor called by subclasses.</p>
<p>Parameters:</p>
<ul>
<li><p><strong>options must be an object.</strong><br/>(The options to build the wrapper. Will be merged with default values (see below))</p>
<ul>
<li><p><strong>options.apiStrategy is optional and must be a string.</strong><br/>(The strategy adopted to fallback on another wrapper if the method does not exists. One of the following values: [&#39;htmlOnly&#39;, &#39;htmlFirst&#39;, &#39;restFirst&#39;, &#39;restOnly&#39;, &#39;custom&#39;])</p>
</li>
<li><p><strong>options.autoAuthentication is optional and must be a boolean.</strong><br/>(To automate or not the authentication process (between the wrapper and Myfox services))</p>
</li>
<li><p><strong>options.autoAuthRetryCredits is optional and must be an integer.</strong><br/>(The amount of tries to authenticate against Myfox services [0-10]. Warning: too many attempts can blacklist your IP)</p>
</li>
<li><p><strong>options.authValidity is optional and must be an integer.</strong><br/>(The amount of seconds a Myfox session SHOULD live [1-86400])</p>
</li>
<li><p><strong>options.myfoxSiteIds is optional and must be an Array of integers.</strong><br/>(The list of site IDs (linked to the same user account) allowed to be used by the wrapper)</p>
</li>
</ul>
</li>
<li><p><strong>fallbackApi is optional and must be a MyfoxWrapperApiCommon.</strong><br/>(Another instance of wrapper to use as fallback if the called method does not exists)</p>
</li>
<li><p><strong>accountCredentials is optional and must be an object.</strong><br/>(The Myfox account credentials)</p>
<ul>
<li><p><strong>accountCredentials.username is optional and must be a string.</strong><br/>(The username (the email used to login on the Myfox interface))</p>
</li>
<li><p><strong>accountCredentials.password is optional and must be a string.</strong><br/>(The password (used to login on the Myfox interface). Stored nowhere except on this dynamic class instance)</p>
</li>
</ul>
</li>
</ul>
<p><strong>Returns a MyfoxWrapperApiCommon</strong><br/>(The instance to use as wrapper or as fallback wrapper inside another one)</p></div></div><div class="code"><div class="wrapper">  constructor (options, fallbackApi, accountCredentials) {
    <span class="hljs-keyword">this</span>.options = <span class="hljs-built_in">Object</span>.assign({}, MyfoxWrapperApiCommon.defaultOptions(), options)
    Joi.assert(<span class="hljs-keyword">this</span>.options, MyfoxWrapperApiCommon.optionsSchema())

    <span class="hljs-keyword">this</span>.accountCredentials = accountCredentials
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.accountCredentials !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.accountCredentials !== <span class="hljs-literal">undefined</span>) {
      Joi.assert(<span class="hljs-keyword">this</span>.accountCredentials, MyfoxWrapperApiCommon.accountCredentialsSchema())
    }

    <span class="hljs-keyword">this</span>.fallbackApi = fallbackApi</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>auth data, statefull</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">this</span>.authenticatedUntil = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()
    <span class="hljs-keyword">this</span>.authenticatedData = <span class="hljs-literal">null</span>
    <span class="hljs-keyword">this</span>.authenticatedSiteId = <span class="hljs-literal">null</span>
    <span class="hljs-keyword">this</span>.cookieJar = {}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>persistent states are event triggerers and registers listeners. Statefull</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">this</span>.persistentStates = {
      status: persistentState(<span class="hljs-string">'status'</span>),
      alarm: persistentState(<span class="hljs-string">'alarm'</span>),
      scenarii: persistentState(<span class="hljs-string">'scenarii'</span>),
      domotic: persistentState(<span class="hljs-string">'domotic'</span>), <span class="hljs-comment">// No dynamic behavior, but we can store supposed states</span>
      data: persistentState(<span class="hljs-string">'data'</span>),
      heat: persistentState(<span class="hljs-string">'heat'</span>)
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>macro action listeners</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">this</span>.macroListeners = []
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Default options merged into options given to the constructor.
See details on the documented constructor.</p></div></div><div class="code"><div class="wrapper">  static defaultOptions () {
    <span class="hljs-keyword">return</span> {
      apiStrategy: <span class="hljs-string">'custom'</span>,
      autoAuthentication: <span class="hljs-literal">true</span>,
      autoAuthRetryCredits: <span class="hljs-number">1</span>, <span class="hljs-comment">// 2 calls maximum means 1 retry</span>
      authValidity: <span class="hljs-number">120</span>, <span class="hljs-comment">// 2 minutes</span>
      myfoxSiteIds: [] <span class="hljs-comment">// must be overriden by your siteIds (most often just one...)</span>
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Options format validator.
See details on the documented constructor.</p></div></div><div class="code"><div class="wrapper">  static optionsSchema () {
    <span class="hljs-keyword">return</span> Joi.object({
      apiStrategy: Joi.string().required().valid([<span class="hljs-string">'htmlOnly'</span>, <span class="hljs-string">'htmlFirst'</span>, <span class="hljs-string">'restFirst'</span>, <span class="hljs-string">'restOnly'</span>, <span class="hljs-string">'custom'</span>]),
      autoAuthentication: Joi.boolean().required(),
      autoAuthRetryCredits: Joi.number().integer().min(<span class="hljs-number">0</span>).max(<span class="hljs-number">10</span>).required(),
      authValidity: Joi.number().integer().min(<span class="hljs-number">1</span>).max(<span class="hljs-number">86400</span>).required(), <span class="hljs-comment">// 10 seconds to 24hrs</span>
      myfoxSiteIds: Joi.array().items(Joi.number().integer().min(<span class="hljs-number">1</span>)).min(<span class="hljs-number">1</span>).required() <span class="hljs-comment">// at least 1 number</span>
    })
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Account credentials format validator.
See details on the documented constructor.</p></div></div><div class="code"><div class="wrapper">  static accountCredentialsSchema () {
    <span class="hljs-keyword">return</span> Joi.object({
      username: Joi.string().required(),
      password: Joi.string().required()
    })
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>MyFox distant caller and auto-authentification system</p></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'>Method callApi</span></p>
<p>Call this when you need to call distant Myfox services.
This method will manage authentication layer.</p>
<p>Parameters:</p>
<ul>
<li><p><strong>url must be a string.</strong><br/>(The HTTP(s) URL to call)</p>
</li>
<li><p><strong>method must be a string.</strong><br/>(The HTTP method in uppercase (GET, POST, PATCH, PUT, DELETE, etc...))</p>
</li>
<li><p><strong>streamParser must be an object.</strong><br/>(A stream parser to pipe on the distant response stream)</p>
</li>
<li><p><strong>queryParams must be an object.</strong><br/>(An object to serialize into the query string)</p>
</li>
<li><p><strong>headers must be an object.</strong><br/>(An object to push into the request headers)</p>
</li>
<li><p><strong>payload must be an object.</strong><br/>(An object to serialize as the request payload)</p>
</li>
</ul>
<p><strong>Returns a Promise</strong><br/>(A promise for asynchronous behavior)</p></div></div><div class="code"><div class="wrapper">  callApi (url, method, streamParser, queryParams, headers, payload) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>No auth needed, handled manually. Just call the service.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.autoAuthentication === <span class="hljs-literal">false</span>) {
      <span class="hljs-built_in">console</span>.info(<span class="hljs-string">'Authentication should be made manually.'</span>)
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((resolve, reject) =&gt; {
        <span class="hljs-keyword">this</span>.callDistant(url, method, queryParams, headers, payload, streamParser, resolve, reject, <span class="hljs-literal">null</span>)
      })
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Try to authenticate function</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">let</span> tryToAuthenticate
    tryToAuthenticate = (retryCredits, callDistant, streamParser, resolve, reject) =&gt; {
      <span class="hljs-keyword">this</span>.authenticate(<span class="hljs-keyword">this</span>.authenticatedData, (err, authData, defaultSiteId) =&gt; {
        <span class="hljs-keyword">if</span> (err) {
          <span class="hljs-keyword">if</span> (retryCredits &gt; <span class="hljs-number">0</span>) { <span class="hljs-comment">// retry one more time</span>
            <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">'Authentication failed. Retrying '</span> + retryCredits + <span class="hljs-string">' times left.'</span>)
            retryCredits--
            <span class="hljs-keyword">return</span> tryToAuthenticate(retryCredits, callDistant, streamParser, resolve, reject)
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">const</span> error = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Authentication failed. No retry credits left.'</span>)
            error.status = <span class="hljs-number">403</span>
            error.previous = err
            <span class="hljs-keyword">return</span> reject(error)
          }
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-built_in">console</span>.info(<span class="hljs-string">'Authenticated against Myfox services at '</span> + <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime())
          <span class="hljs-keyword">this</span>.authenticatedUntil.setTime(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime() + (<span class="hljs-keyword">this</span>.options.authValidity * <span class="hljs-number">1000</span>))
          <span class="hljs-keyword">this</span>.authenticatedData = authData
          <span class="hljs-keyword">this</span>.authenticatedSiteId = defaultSiteId
          <span class="hljs-keyword">return</span> callDistant(url, method, queryParams, headers, payload, streamParser, resolve, reject, <span class="hljs-literal">null</span>)
        }
      })
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((resolve, reject) =&gt; {
      <span class="hljs-keyword">let</span> authCredits = <span class="hljs-keyword">this</span>.options.autoAuthRetryCredits</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>For sure, we need to auth before calling service</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isMaybeAuthenticated()) {
        <span class="hljs-built_in">console</span>.info(<span class="hljs-string">'(RE)Authentication needed.'</span>)
        tryToAuthenticate(authCredits, <span class="hljs-keyword">this</span>.callDistant.bind(<span class="hljs-keyword">this</span>), streamParser, resolve, reject)
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">console</span>.info(<span class="hljs-string">'Authentication should not be needed...'</span>)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Maybe we are still authenticated. Try service and see... if fails auth and try again once.</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">this</span>.callDistant(url, method, queryParams, headers, payload, streamParser, resolve, reject, () =&gt; {
          tryToAuthenticate(authCredits, <span class="hljs-keyword">this</span>.callDistant.bind(<span class="hljs-keyword">this</span>), streamParser, resolve, reject)
        })
      }
    })
  }

  isMaybeAuthenticated () {
    <span class="hljs-keyword">const</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.authenticatedUntil &gt; now
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Wrapper API methods</p></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Call Myfox authentication process.
This method must be overridden in the extended api implementation.</p>
<p>Parameters:</p>
<ul>
<li><p><strong>authData must be an object.</strong><br/>(Authentication data that comes from previous authentication)</p>
</li>
<li><p><strong>callback must be a function.</strong><br/>(To use when the authentication is done (fail or success), with parameters: (err, authData))</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">  authenticate (authData, callback) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Feature not implemented in this wrapper.'</span>)
  }</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Call Myfox interface with the action/query.
This method must be overridden in the extended api implementation.
Do not use this method directly to call Myfox services. Prefer use this.callApi(url, method, queryParams, headers, payload)</p>
<p>Parameters:</p>
<ul>
<li><p><strong>url must be a string.</strong><br/>(The HTTP(s) URL to call. This url will be parsed in subclasses to replace {siteId} by its value)</p>
</li>
<li><p><strong>method must be a string.</strong><br/>(The HTTP method in uppercase (GET, POST, PATCH, PUT, DELETE, etc...))</p>
</li>
<li><p><strong>queryParams must be an object.</strong><br/>(An object to serialize into the query string)</p>
</li>
<li><p><strong>headers must be an object.</strong><br/>(An object to push into the request headers)</p>
</li>
<li><p><strong>payload must be an object.</strong><br/>(An object to serialize as the request payload)</p>
</li>
<li><p><strong>streamParser must be an object.</strong><br/>(A stream parser to pipe on the distant response stream)</p>
</li>
<li><p><strong>resolve must be a function.</strong><br/>(The callback to use if the call succeeds (with data as unique parameter))</p>
</li>
<li><p><strong>reject must be a function.</strong><br/>(The callback to use if the call fails (with the error as unique parameter))</p>
</li>
<li><p><strong>reAuthenticate must be a function.</strong><br/>(The callback to use if the call received a 403 error, to force a new loop with an authentication process. May be null ! In this case, throw an error)</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">  callDistant (url, method, queryParams, headers, payload, streamParser, resolve, reject, reAuthenticate) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Feature not implemented in this wrapper.'</span>)
  }</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Adds a listener to a persistent state, given a state label.
The listener is a function, that will be called with the following arguments:</p>
<ul>
<li>state label,</li>
<li>new state value,</li>
<li>previous state value,</li>
<li>a timestamp (creation date of the event)</li>
</ul>
<p>Parameters:</p>
<ul>
<li><p><strong>label must be a string.</strong><br/>(The unique label that identifies a persistent state)</p>
</li>
<li><p><strong>listener must be a function.</strong><br/>(The listener function to call if the state changes)</p>
</li>
</ul>
<p><strong>Returns a boolean</strong><br/>(True if the listener is added, false if already registered)</p></div></div><div class="code"><div class="wrapper">  addStateListener (label, listener) {
    <span class="hljs-keyword">let</span> state = <span class="hljs-keyword">this</span>.persistentStates[label]
    <span class="hljs-keyword">if</span> (state === <span class="hljs-literal">null</span> || state === <span class="hljs-literal">undefined</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`The state label <span class="hljs-subst">${label}</span> does not exists`</span>)
    }
    <span class="hljs-keyword">return</span> state.addListener(listener)
  }</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Adds a listener to any macro action that can occurs.
The listener is a function, that will be called with the following arguments:</p>
<ul>
<li>macro ID,</li>
<li>data: an object with the parser response, depending on the call made,</li>
<li>state: a label with the following allowed values: progress, finished,</li>
<li>remaining: The number of steps in the macro still in the queue. When remaining==0, then the state should be &#39;finished&#39;.</li>
<li>timestamp: a timestamp (creation date of the event)
Important: the listener must return a boolean:</li>
<li>true to be kept for the next event,</li>
<li>false if the listener must be unregistered after this event.</li>
</ul>
<p>Parameters:</p>
<ul>
<li><strong>listener must be a function.</strong><br/>(The listener function to call if the state changes)</li>
</ul>
<p><strong>Returns a boolean</strong><br/>(True if the listener is added, false if already registered)</p></div></div><div class="code"><div class="wrapper">  addMacroListener (listener) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.macroListeners.indexOf(listener) !== -<span class="hljs-number">1</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    }
    <span class="hljs-keyword">this</span>.macroListeners.push(listener)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
  }</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Removes a listener if it is already registered.
The listener is the function previously given to addMacroListener() method.</p>
<p>Parameters:</p>
<ul>
<li><strong>listener must be a function.</strong><br/>(The listener function to remove from the registery)</li>
</ul>
<p><strong>Returns a boolean</strong><br/>(True if the listener is removed, false if it is not found)</p></div></div><div class="code"><div class="wrapper">  removeMacroListener (listener) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.macroListeners.indexOf(listener) === -<span class="hljs-number">1</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    }
    <span class="hljs-keyword">let</span> listeners = <span class="hljs-keyword">this</span>.macroListeners.filter((element) =&gt; { <span class="hljs-keyword">return</span> element !== listener })
    <span class="hljs-keyword">this</span>.macroListeners = listeners
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
  }</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Sends a notification to the macro listeners.
Each listener is notified with the arguments described on the addMacroListener() documentation.
If the err parameter is not null, the the listeners are not notified. The err will be logged instead.</p>
<p>Parameters:</p>
<ul>
<li><p><strong>err must be an Object.</strong><br/>(The error if the event encountered an error, null in the other cases)</p>
</li>
<li><p><strong>info is optional and must be an Object.</strong><br/>(Information about the event)</p>
<ul>
<li><p><strong>info.id must be a string.</strong><br/>(The unique ID of the macro. This is usefull to follow a specific macro that can triggers many events)</p>
</li>
<li><p><strong>info.data must be an Object.</strong><br/>(The data sent by the event emitter. Can vary)</p>
</li>
<li><p><strong>info.state must be a string.</strong><br/>(The state of the macro. Can be one of: progress, finished)</p>
</li>
<li><p><strong>info.remaining must be an integer.</strong><br/>(The size of step stack still to execute. If 0, then state should be &#39;finished&#39;)</p>
</li>
</ul>
</li>
</ul></div></div><div class="code"><div class="wrapper">  notifyMacroListeners (err, {id, data = {}, state = <span class="hljs-literal">null</span>, remaining = <span class="hljs-number">0</span>}) {
    <span class="hljs-keyword">if</span> (err) {
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.error(err)
    }
    <span class="hljs-keyword">let</span> now = <span class="hljs-built_in">Date</span>.now()
    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">`Macro state updated on <span class="hljs-subst">${id}</span>, sending to <span class="hljs-subst">${this.macroListeners.length}</span> listeners...`</span>)
    <span class="hljs-keyword">this</span>.macroListeners.forEach((listener) =&gt; {
      <span class="hljs-keyword">if</span> (!listener(id, data, state, remaining, now)) {
        <span class="hljs-keyword">this</span>.removeMacroListener(listener)
      }
    })
  }</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Calls main page (/home) to retrieve data like alarm level, box status, default site info, and other subparts.
This call is made for HTML wrapper. Rest wrapper does not provides this call.</p>
<p>You should use this call to test your connection. In the same time, this call will give you data to keep in cache:</p>
<ul>
<li>scenarii list</li>
<li>domotic stuff list</li>
<li>heat list</li>
<li>data list
Except the fact that some of these can change their value, the list of their IDs cannot change realy often,
and in case of change, a persistantState listener can be called.</li>
</ul>
<p>Parameters:</p>
<ul>
<li><strong>callback must be a function.</strong><br/>(The function to call with all data retrieved through /home)</li>
</ul></div></div><div class="code"><div class="wrapper">  callHome (callback) {
    _notImplemented.bind(<span class="hljs-keyword">this</span>)(<span class="hljs-string">'callHome'</span>, callback)
  }</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Calls scenario action (/widget/{siteId}/scenario/{action}/{id}) to turn on/off or to activate a scenario.
The possible action depends on the action type (on demand or not).</p>
<p>Parameters:</p>
<ul>
<li><p><strong>info is optional and must be an Object.</strong><br/>(Information to trigger the event.)</p>
<ul>
<li><p><strong>info.id must be an integer.</strong><br/>(The unique ID of the scenario to play action against.)</p>
</li>
<li><p><strong>info.action must be a string.</strong><br/>(The action to trigger. Can be play for &#39;on demand&#39; scenario, on or off for others.)</p>
</li>
<li><p><strong>info.delay must be an integer.</strong><br/>(The delay (optional) to wait before triggering the action. If &gt; 0 then the method will callback just after scheduling of the action.)</p>
</li>
</ul>
</li>
<li><p><strong>callback must be a function.</strong><br/>(The function to call with all data, depending on the step of the action macro: in the simplest case (one action, no delay), then the result of the call to Myfox. In other cases, an ID to follow with a macro listener The callback parameters must follows the same signature as a macro listener (see addMacroListener() method).)</p>
</li>
<li><p><strong>macroId is optional and must be a string.</strong><br/>(Optional ID to keep track of the action if multiple steps or delay is provided.)</p>
</li>
<li><p><strong>info must be an Array of Objects.</strong><br/>([]] The next actions informations, like the first param.)</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">  callScenarioAction ({id, action, delay = <span class="hljs-number">0</span>}, callback, macroId = <span class="hljs-literal">undefined</span>, ...nextActions) {
    _notImplemented.bind(<span class="hljs-keyword">this</span>)(<span class="hljs-string">'callScenarioAction'</span>, callback)
  }</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Calls domotic switch action (/widget/{siteId}/domotic/{action}/{id}) to turn on/off a domotic switch.</p>
<p>Parameters:</p>
<ul>
<li><p><strong>info is optional and must be an Object.</strong><br/>(Information to trigger the event.)</p>
<ul>
<li><p><strong>info.id must be an integer.</strong><br/>(The unique ID of the domotic switch to play action against.)</p>
</li>
<li><p><strong>info.action must be a string.</strong><br/>(The action to trigger. Can be on or off.)</p>
</li>
<li><p><strong>info.delay must be an integer.</strong><br/>(The delay (optional) to wait before triggering the action. If &gt; 0 then the method will callback just after scheduling of the action.)</p>
</li>
</ul>
</li>
<li><p><strong>callback must be a function.</strong><br/>(The function to call with all data, depending on the step of the action macro: in the simplest case (one action, no delay), then the result of the call to Myfox. In other cases, an ID to follow with a macro listener The callback parameters must follows the same signature as a macro listener (see addMacroListener() method).)</p>
</li>
<li><p><strong>macroId is optional and must be a string.</strong><br/>(Optional ID to keep track of the action if multiple steps or delay is provided.)</p>
</li>
<li><p><strong>info must be an Array of Objects.</strong><br/>([]] The next actions informations, like the first param.)</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">  callDomoticAction ({id, action, delay = <span class="hljs-number">0</span>}, callback, macroId = <span class="hljs-literal">undefined</span>, ...nextActions) {
    _notImplemented.bind(<span class="hljs-keyword">this</span>)(<span class="hljs-string">'callDomoticAction'</span>, callback)
  }</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Calls heating 4 orders piloted (/widget/{siteId}/heating/{action}/{id}) to turn on/eco/frost/off a heating.</p>
<p>Parameters:</p>
<ul>
<li><p><strong>info is optional and must be an Object.</strong><br/>(Information to trigger the event.)</p>
<ul>
<li><p><strong>info.id must be an integer.</strong><br/>(The unique ID of the heating pilot to play action against.)</p>
</li>
<li><p><strong>info.action must be a string.</strong><br/>(The action to trigger. Can be on, eco, frost or off.)</p>
</li>
<li><p><strong>info.delay must be an integer.</strong><br/>(The delay (optional) to wait before triggering the action. If &gt; 0 then the method will callback just after scheduling of the action.)</p>
</li>
</ul>
</li>
<li><p><strong>callback must be a function.</strong><br/>(The function to call with all data, depending on the step of the action macro: in the simplest case (one action, no delay), then the result of the call to Myfox. In other cases, an ID to follow with a macro listener The callback parameters must follows the same signature as a macro listener (see addMacroListener() method).)</p>
</li>
<li><p><strong>macroId is optional and must be a string.</strong><br/>(Optional ID to keep track of the action if multiple steps or delay is provided.)</p>
</li>
<li><p><strong>info must be an Array of Objects.</strong><br/>([]] The next actions informations, like the first param.)</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">  callHeatingAction ({id, action, delay = <span class="hljs-number">0</span>}, callback, macroId = <span class="hljs-literal">undefined</span>, ...nextActions) {
    _notImplemented.bind(<span class="hljs-keyword">this</span>)(<span class="hljs-string">'callHeatingAction'</span>, callback)
  }</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Modifies the alarm level (off, half, on).</p>
<p>Parameters:</p>
<ul>
<li><p><strong>info is optional and must be an Object.</strong><br/>(Information to trigger the event.)</p>
<ul>
<li><p><strong>info.action must be a string.</strong><br/>(The level to trigger. Can be on, half or off.)</p>
</li>
<li><p><strong>info.password must be a string.</strong><br/>(The password, as for authentication process, only if the alarm level must be off or half.)</p>
</li>
</ul>
</li>
<li><p><strong>callback must be a function.</strong><br/>(The function to call with all data, depending on the step of the action macro: in the simplest case (one action, no delay), then the result of the call to Myfox. In other cases, an ID to follow with a macro listener The callback parameters must follows the same signature as a macro listener (see addMacroListener() method).)</p>
</li>
<li><p><strong>macroId is optional and must be a string.</strong><br/>(Optional ID to keep track of the action if multiple steps or delay is provided.)</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">  callAlarmLevelAction ({action, password = <span class="hljs-literal">undefined</span>}, callback, macroId = <span class="hljs-literal">undefined</span>) {
    _notImplemented.bind(<span class="hljs-keyword">this</span>)(<span class="hljs-string">'callAlarmLevelAction'</span>, callback)
  }</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Uses edition mode to inspect a scenario and get its temperature settings (HTML strategy only)</p>
<p>Parameters:</p>
<ul>
<li><p><strong>scenarioId must be a string.</strong><br/>(The ID of the scenario to inspect. The scenario edition will not modify any parameter.)</p>
</li>
<li><p><strong>callback must be a function.</strong><br/>(The function to call with all data.)</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">  inspectScenarioTemperatureSettings (scenarioId, callback) {
    _notImplemented.bind(<span class="hljs-keyword">this</span>)(<span class="hljs-string">'inspectScenarioTemperatureSettings'</span>, callback)
  }</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Uses edition mode to inspect and modify a scenario, in order to change temperature conditions values (HTML strategy only)</p>
<p>The temperature conditions are hard coded and supports 3 conditions, described by their HTML names here:</p>
<ul>
<li>trigger_4: the main trigger of the scenario: you can find it in the tabs of events that will execute the scenario</li>
<li>condition_4_1: the first condition that you can add after the main trigger: you can find it in a list of checkable conditions.</li>
<li>condition_4_2: the second sub-condition that appears when the condition_4_1 is already checked and set.</li>
</ul>
<p>Parameters:</p>
<ul>
<li><p><strong>scenarioId must be a string.</strong><br/>(The ID of the scenario to modify. The scenario edition WILL modify parameters depending on the settings given.)</p>
</li>
<li><p><strong>settings must be an Array of Objects.</strong><br/>(An array of temperature values to modify, associated to the conditions to look in.)</p>
</li>
<li><p><strong>callback must be a function.</strong><br/>(The function to call with all data.)</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">  updateScenarioTemperatureSettings (scenarioId, settings, callback) {
    _notImplemented.bind(<span class="hljs-keyword">this</span>)(<span class="hljs-string">'updateScenarioTemperatureSettings'</span>, callback)
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> MyfoxWrapperApiCommon</div></div></div></div></body></html>