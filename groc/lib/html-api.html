<!DOCTYPE html><html lang="en"><head><title>lib/html-api</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="lib/html-api"><meta name="groc-project-path" content="lib/html-api.js"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path">lib/html-api.js</div></div><div id="document"><div class="segment"><div class="code"><div class="wrapper"><span class="hljs-pi">'use strict'</span>

<span class="hljs-keyword">import</span> JsonStream <span class="hljs-keyword">from</span> <span class="hljs-string">'JSONStream'</span>
<span class="hljs-keyword">import</span> config <span class="hljs-keyword">from</span> <span class="hljs-string">'config'</span>
<span class="hljs-keyword">import</span> Joi <span class="hljs-keyword">from</span> <span class="hljs-string">'joi'</span>
<span class="hljs-keyword">import</span> crypto <span class="hljs-keyword">from</span> <span class="hljs-string">'crypto'</span>
<span class="hljs-keyword">import</span> cloneDeep <span class="hljs-keyword">from</span> <span class="hljs-string">'clone-deep'</span>

<span class="hljs-keyword">import</span> MyfoxWrapperApiCommon <span class="hljs-keyword">from</span> <span class="hljs-string">'./common-api'</span>
<span class="hljs-keyword">import</span> { httpsRequest } <span class="hljs-keyword">from</span> <span class="hljs-string">'./html-parsers'</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Html parsers</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">import</span> homeParser <span class="hljs-keyword">from</span> <span class="hljs-string">'./html-parsers/home'</span>
<span class="hljs-keyword">import</span> simpleCodeActionParser <span class="hljs-keyword">from</span> <span class="hljs-string">'./html-parsers/simple-code-action'</span>
<span class="hljs-keyword">import</span> { step1Parser, step2Parser, step3TempInspectionParser, step3TempModificationParser,
    step3TempFixer, step4Parser, step5Parser } <span class="hljs-keyword">from</span> <span class="hljs-string">'./html-parsers/scenario_edition'</span>

class MyfoxWrapperApiHtml extends MyfoxWrapperApiCommon {</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Html version constructor.
This overrides the default constructor to add HTML parameters to the configuration.</p>
<p>Parameters:</p>
<ul>
<li><p><strong>options must be an object.</strong><br/>(The options to build the wrapper. Will be merged with default values (see below))</p>
<ul>
<li><p><strong>options.apiStrategy is optional and must be a string.</strong><br/>(The strategy adopted to fallback on another wrapper if the method does not exists. One of the following values: [&#39;htmlOnly&#39;, &#39;htmlFirst&#39;, &#39;restFirst&#39;, &#39;restOnly&#39;, &#39;custom&#39;])</p>
</li>
<li><p><strong>options.autoAuthentication is optional and must be a boolean.</strong><br/>(To automate or not the authentication process (between the wrapper and Myfox services))</p>
</li>
<li><p><strong>options.autoAuthRetryCredits is optional and must be an integer.</strong><br/>(The amount of tries to authenticate against Myfox services [0-10]. Warning: too many attempts can blacklist your IP)</p>
</li>
<li><p><strong>options.authValidity is optional and must be an integer.</strong><br/>(The amount of seconds a Myfox session SHOULD live [1-86400])</p>
</li>
<li><p><strong>options.myfoxSiteIds is optional and must be an Array of integers.</strong><br/>(The list of site IDs (linked to the same user account) allowed to be used by the wrapper)</p>
</li>
</ul>
</li>
<li><p><strong>fallbackApi is optional and must be a MyfoxWrapperApiCommon.</strong><br/>(Another instance of wrapper to use as fallback if the called method does not exists)</p>
</li>
<li><p><strong>accountCredentials is optional and must be an object.</strong><br/>(The Myfox account credentials)</p>
<ul>
<li><p><strong>accountCredentials.username is optional and must be a string.</strong><br/>(The username (the email used to login on the Myfox interface))</p>
</li>
<li><p><strong>accountCredentials.password is optional and must be a string.</strong><br/>(The password (used to login on the Myfox interface). Stored nowhere except on this dynamic class instance)</p>
</li>
</ul>
</li>
</ul>
<p><strong>Returns a MyfoxWrapperApiCommon</strong><br/>(The instance to use as wrapper or as fallback wrapper inside another one)</p></div></div><div class="code"><div class="wrapper">  constructor (options, fallbackApi, accountCredentials) {
    <span class="hljs-keyword">super</span>(options, fallbackApi, accountCredentials)
    <span class="hljs-keyword">try</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Success only if used as a dependency.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">const</span> defaultConfig = {<span class="hljs-string">'html'</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">'../config/default.json'</span>)[<span class="hljs-string">'myfox-wrapper-api'</span>][<span class="hljs-string">'html'</span>]}
      config.util.setModuleDefaults(<span class="hljs-string">'myfox-wrapper-api'</span>, defaultConfig)
    } <span class="hljs-keyword">catch</span> (err) {
    }
  }</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Call Myfox authentication process (login form filled in POST method).
Do not use this method directly to login to Myfox services: the auth will not be stored.</p>
<p>Parameters:</p>
<ul>
<li><p><strong>authData must be an object.</strong><br/>(Authentication data that comes from previous authentication.)</p>
</li>
<li><p><strong>callback must be a function.</strong><br/>(To use when the authentication is done (fail or success), with parameters: (err, authData))</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">  authenticate (authData, callback) {
    <span class="hljs-keyword">const</span> validSiteIds = <span class="hljs-keyword">this</span>.options.myfoxSiteIds || []
    <span class="hljs-keyword">try</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Call <a href="https://myfox.me/login">https://myfox.me/login</a>&#39;, POST, payload={&#39;username&#39;, &#39;password&#39;}
Receive {&#39;code&#39;: &quot;KO&quot;} OR {rdt: [&quot;<a href="https://myfox.me/home/XXXX">https://myfox.me/home/XXXX</a>&quot;, 0]}</p></div></div><div class="code"><div class="wrapper">      httpsRequest(
        <span class="hljs-string">'POST'</span>,
        config.get(<span class="hljs-string">'myfox-wrapper-api.html.myfox.paths.login'</span>),
        JsonStream.parse(<span class="hljs-string">'rdt'</span>).on(<span class="hljs-string">'data'</span>, (data) =&gt; {
          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">const</span> siteId = data[<span class="hljs-number">0</span>].split(<span class="hljs-string">'/'</span>).pop()
            <span class="hljs-keyword">if</span> (validSiteIds.indexOf(<span class="hljs-built_in">parseInt</span>(siteId)) === -<span class="hljs-number">1</span>) {
              <span class="hljs-built_in">console</span>.error(<span class="hljs-string">`Authenticated with a forbidden siteId (<span class="hljs-subst">${siteId}</span>). Please check your configuration (server.myfox.myfoxSiteIds)`</span>)
              <span class="hljs-keyword">const</span> error = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Forbidden siteId. The server is restricted to a list of siteIds and your does not match one of them.'</span>)
              error.status = <span class="hljs-number">449</span>
              <span class="hljs-keyword">return</span> callback(error)
            }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>transfer of auth data (containing default siteId)</p></div></div><div class="code"><div class="wrapper">            <span class="hljs-keyword">return</span> callback(<span class="hljs-literal">null</span>, data, siteId)
          } <span class="hljs-keyword">catch</span> (err) {
            err.status = <span class="hljs-number">500</span>
            <span class="hljs-keyword">return</span> callback(err)
          }
        }),
        (err) =&gt; {
          <span class="hljs-keyword">if</span> (err) {
            <span class="hljs-keyword">return</span> callback(err)
          }
        },
        {},
        {<span class="hljs-string">'username'</span>: <span class="hljs-keyword">this</span>.accountCredentials.username, <span class="hljs-string">'password'</span>: <span class="hljs-keyword">this</span>.accountCredentials.password},
        config.get(<span class="hljs-string">'myfox-wrapper-api.html.myfox.headers_login'</span>),
        (cookie) =&gt; {
          <span class="hljs-keyword">if</span> (cookie !== <span class="hljs-literal">null</span> &amp;&amp; cookie !== <span class="hljs-literal">undefined</span>) {
            <span class="hljs-keyword">this</span>.cookieJar = cookie
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.cookieJar
          }
        }
      )
    } <span class="hljs-keyword">catch</span> (err) {
      <span class="hljs-built_in">console</span>.error(err)
      callback(err)
    }
  }</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Call Myfox interface with the action/query.
Do not use this method directly to call Myfox services. Prefer use this.callApi(url, method, queryParams, headers, payload).</p>
<p>Parameters:</p>
<ul>
<li><p><strong>url must be a string.</strong><br/>(The HTTP(s) URL to call. This url will be parsed to replace {siteId} by its value)</p>
</li>
<li><p><strong>method must be a string.</strong><br/>(The HTTP method (get, post, patch, put, delete))</p>
</li>
<li><p><strong>queryParams must be an object.</strong><br/>(An object to serialize into the query string)</p>
</li>
<li><p><strong>headers must be an object.</strong><br/>(An object to push into the request headers)</p>
</li>
<li><p><strong>payload must be an object.</strong><br/>(An object to serialize as the request payload)</p>
</li>
<li><p><strong>streamParser must be an object.</strong><br/>(a stream parser to pipe on the distant response stream)</p>
</li>
<li><p><strong>resolve must be a function.</strong><br/>(The callback to use if the call succeeds (with data as unique parameter))</p>
</li>
<li><p><strong>reject must be a function.</strong><br/>(The callback to use if the call fails (with the error as unique parameter))</p>
</li>
<li><p><strong>reAuthenticate must be a function.</strong><br/>(The callback to use if the call received a 403 error, to force a new loop with an authentication process. May be null ! In this case, throw an error.)</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">  callDistant (url, method, queryParams, headers, payload, streamParser, resolve, reject, reAuthenticate) {
    <span class="hljs-keyword">const</span> path = url.replace(<span class="hljs-string">'{siteId}'</span>, <span class="hljs-keyword">this</span>.authenticatedSiteId)
    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">'Routing - call distant:'</span>, method, path)
    httpsRequest(
      method,
      path,
      streamParser,
      (err, fullData) =&gt; {
        <span class="hljs-keyword">if</span> (err) {
          <span class="hljs-keyword">if</span> (err.status === <span class="hljs-literal">null</span> || err.status === <span class="hljs-literal">undefined</span>) {
            err.status = <span class="hljs-number">500</span>
          }
          <span class="hljs-keyword">if</span> (err.status === <span class="hljs-number">403</span> &amp;&amp; reAuthenticate !== <span class="hljs-literal">null</span> &amp;&amp; reAuthenticate !== <span class="hljs-literal">undefined</span>) {
            <span class="hljs-keyword">return</span> reAuthenticate()
          }
          <span class="hljs-keyword">return</span> reject(err)
        }
        resolve(fullData || <span class="hljs-literal">true</span>)
      },
      queryParams,
      payload,
      headers,
      (cookie) =&gt; {
        <span class="hljs-keyword">if</span> (cookie !== <span class="hljs-literal">null</span> &amp;&amp; cookie !== <span class="hljs-literal">undefined</span>) {
          <span class="hljs-keyword">this</span>.cookieJar = cookie
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.cookieJar
        }
      }
    )
  }</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Calls main page (/home) to retrieve data like alarm level, box status, default site info, and other subparts.
This call is made for HTML wrapper. Rest wrapper does not provides this call.</p>
<p>You should use this call to test your connection. In the same time, this call will give you data to keep in cache:</p>
<ul>
<li>scenarii list</li>
<li>domotic stuff list</li>
<li>heat list</li>
<li>data list
Except the fact that some of these can change their value, the list of their IDs cannot change really often,
and in case of change, a persistantState listener can be called.</li>
</ul>
<p>Parameters:</p>
<ul>
<li><strong>callback must be a function.</strong><br/>(The function to call with all data retrieved through /home.)</li>
</ul></div></div><div class="code"><div class="wrapper">  callHome (callback) {
    <span class="hljs-keyword">super</span>.callApi(config.get(<span class="hljs-string">'myfox-wrapper-api.html.myfox.paths.home'</span>), <span class="hljs-string">'GET'</span>, homeParser(<span class="hljs-keyword">this</span>), {}, {}, {})
      .then((parser) =&gt; {
        callback(<span class="hljs-literal">null</span>, {
          status: parser.status,
          scenarii: parser.scenarii,
          alarm: parser.alarm,
          domotic: parser.domotic,
          data: parser.data,
          heat: parser.heat
        })
      })
      .catch((err) =&gt; {
        <span class="hljs-built_in">console</span>.error(err)
        callback(err)
      })
  }</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Calls scenario action (/widget/{siteId}/scenario/{action}/{id}) to turn on/off or to activate a scenario.
The possible action depends on the action type (on demand or not).</p>
<p>Parameters:</p>
<ul>
<li><p><strong>info is optional and must be an Object.</strong><br/>(Information to trigger the event)</p>
<ul>
<li><p><strong>info.id must be a string.</strong><br/>(The unique ID of the scenario to play action against)</p>
</li>
<li><p><strong>info.action must be a string.</strong><br/>(The action to trigger. Can be play for &#39;on demand&#39; scenario, on or off for others)</p>
</li>
<li><p><strong>info.delay must be an integer.</strong><br/>(The delay (optional) to wait before triggering the action. If &gt; 0 then the method will callback just after scheduling of the action)</p>
</li>
</ul>
</li>
<li><p><strong>callback must be a function.</strong><br/>(The function to call with all data, depending on the step of the action macro: in the simplest case (one action, no delay), then the result of the call to Myfox. In other cases, an ID to follow with a macro listener The callback parameters must follows the same signature as a macro listener (see addMacroListener() method))</p>
</li>
<li><p><strong>macroId is optional and must be a string.</strong><br/>(Optional ID to keep track of the action if multiple steps or delay is provided.)</p>
</li>
<li><p><strong>info must be an Array of Objects.</strong><br/>([]] The next actions informations, like the first param)</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">  callScenarioAction ({id, action, delay = <span class="hljs-number">0</span>}, callback, macroId = <span class="hljs-literal">undefined</span>, ...nextActions) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Validation of parameters</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">const</span> validator = Joi.object({
      id: Joi.number().integer().required().positive(),
      action: Joi.string().required().valid([<span class="hljs-string">'on'</span>, <span class="hljs-string">'off'</span>, <span class="hljs-string">'play'</span>]),
      delay: Joi.number().integer().min(<span class="hljs-number">0</span>).optional().default(<span class="hljs-number">0</span>)
    })

    Joi.assert({id, action, delay}, validator)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If nextActions not empty, then check structure</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> nextAction <span class="hljs-keyword">of</span> nextActions) {
      Joi.assert(nextAction, validator)
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If there is a delay, or nextActions, then an ID should be returned to allow a listener to be registered.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (delay &gt; <span class="hljs-number">0</span> || nextActions.length &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">this</span>._callScenarioAction({id, action, delay}, callback, macroId || crypto.randomBytes(<span class="hljs-number">20</span>).toString(<span class="hljs-string">'hex'</span>), ...nextActions)
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">this</span>._callScenarioAction({id, action, delay: <span class="hljs-number">0</span>}, callback)
    }
  }</div></div></div><div class="segment"><div class="comments doc-section doc-section-private"><div class="wrapper"><p><span class='doc-section-header'>Private</span></p>
<p>Subcall of callScenarioAction() to allow recursive call, and to keep unique macro ID over all the macro steps.</p>
<p>Parameters:</p>
<ul>
<li><p><strong>info is optional and must be an Object.</strong><br/>(Information to trigger the event)</p>
<ul>
<li><p><strong>info.id must be an integer.</strong><br/>(The unique ID of the scenario to play action against)</p>
</li>
<li><p><strong>info.action must be a string.</strong><br/>(The action to trigger. Can be play for &#39;on demand&#39; scenario, on or off for others)</p>
</li>
<li><p><strong>info.delay must be an integer.</strong><br/>(The delay (optional) to wait before triggering the action. If &gt; 0 then the method will callback just after scheduling of the action)</p>
</li>
</ul>
</li>
<li><p><strong>callback must be a function.</strong><br/>(The function to call with all data, depending on the step of the action macro: in the simplest case (one action, no delay), then the result of the call to Myfox. In other cases, the macro ID to follow with a macro listener The callback parameters must follows the same signature as a macro listener (see addMacroListener() method))</p>
</li>
<li><p><strong>macroId must be an integer.</strong><br/>(The unique ID to follow each step of the macro. This Id is returned in the callback, and can be used to follow the macro trougth a macro listener)</p>
</li>
<li><p><strong>info must be an Array of Objects.</strong><br/>([]] The next actions informations, like the first param)</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">  _callScenarioAction ({id, action, delay = <span class="hljs-number">0</span>}, callback, macroId = <span class="hljs-literal">null</span>, ...nextActions) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Call Api for first action (or schedule it if delayed), THEN schedule next.
If scheduled, cannot return the state in the callback: will return an ID to register a listener.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (delay &gt; <span class="hljs-number">0</span>) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Delayed case: returns directly with an ID, and schedules calling itself for later.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">const</span> that = <span class="hljs-keyword">this</span>
      setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        that._callScenarioAction({id, action, delay: <span class="hljs-number">0</span>}, that.notifyMacroListeners.bind(that), macroId, ...nextActions)
      }, delay)
      callback(<span class="hljs-literal">null</span>, { id: macroId, state: <span class="hljs-string">'delayed'</span>, remaining: nextActions.length })
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">let</span> url = config.get(<span class="hljs-string">'myfox-wrapper-api.html.myfox.paths.scenario_action'</span>).replace(<span class="hljs-string">'{action}'</span>, action).replace(<span class="hljs-string">'{id}'</span>, id)
      <span class="hljs-keyword">this</span>.callApi(url, <span class="hljs-string">'POST'</span>, simpleCodeActionParser(<span class="hljs-keyword">this</span>), {}, {}, {})
        .then((parser) =&gt; {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If action succeed and on/off, then must update persistentStates</p></div></div><div class="code"><div class="wrapper">          <span class="hljs-keyword">if</span> (parser.status === <span class="hljs-string">'ok'</span> &amp;&amp; action !== <span class="hljs-string">'play'</span>) {
            <span class="hljs-keyword">const</span> scenarii = cloneDeep(<span class="hljs-keyword">this</span>.persistentStates.scenarii.value)
            scenarii[id].active = (action === <span class="hljs-string">'on'</span>) ? <span class="hljs-string">'1'</span> : <span class="hljs-string">'0'</span>
            <span class="hljs-keyword">this</span>.persistentStates.scenarii.push(scenarii)
          }
          callback(<span class="hljs-literal">null</span>, {
            id: macroId,
            data: parser.data,
            state: (nextActions.length &gt; <span class="hljs-number">0</span>) ? <span class="hljs-string">'progress'</span> : <span class="hljs-string">'finished'</span>,
            remaining: nextActions.length
          })</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If still some steps after, then call in recursive way</p></div></div><div class="code"><div class="wrapper">          <span class="hljs-keyword">if</span> (nextActions.length &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">let</span> nextAction = nextActions.shift()
            <span class="hljs-keyword">this</span>._callScenarioAction(nextAction, <span class="hljs-keyword">this</span>.notifyMacroListeners.bind(<span class="hljs-keyword">this</span>), macroId, ...nextActions)
          }
        })
        .catch((err) =&gt; {
          <span class="hljs-built_in">console</span>.error(err)
          callback(err)
        })
    }
  }</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Calls domotic switch action (/widget/{siteId}/domotic/{action}/{id}) to turn on/off a domotic switch.</p>
<p>Parameters:</p>
<ul>
<li><p><strong>info is optional and must be an Object.</strong><br/>(Information to trigger the event)</p>
<ul>
<li><p><strong>info.id must be an integer.</strong><br/>(The unique ID of the domotic switch to play action against)</p>
</li>
<li><p><strong>info.action must be a string.</strong><br/>(The action to trigger. Can be on or off)</p>
</li>
<li><p><strong>info.delay must be an integer.</strong><br/>(The delay (optional) to wait before triggering the action. If &gt; 0 then the method will callback just after scheduling of the action)</p>
</li>
</ul>
</li>
<li><p><strong>callback must be a function.</strong><br/>(The function to call with all data, depending on the step of the action macro: in the simplest case (one action, no delay), then the result of the call to Myfox. In other cases, an ID to follow with a macro listener The callback parameters must follows the same signature as a macro listener (see addMacroListener() method))</p>
</li>
<li><p><strong>macroId is optional and must be a string.</strong><br/>(Optional ID to keep track of the action if multiple steps or delay is provided.)</p>
</li>
<li><p><strong>info must be an Array of Objects.</strong><br/>([]] The next actions informations, like the first param)</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">  callDomoticAction ({id, action, delay = <span class="hljs-number">0</span>}, callback, macroId = <span class="hljs-literal">undefined</span>, ...nextActions) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Validation of parameters</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">const</span> validator = Joi.object({
      id: Joi.number().integer().required().positive(),
      action: Joi.string().required().valid([<span class="hljs-string">'on'</span>, <span class="hljs-string">'off'</span>]),
      delay: Joi.number().integer().min(<span class="hljs-number">0</span>).optional().default(<span class="hljs-number">0</span>)
    })

    Joi.assert({id, action, delay}, validator)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If nextActions not empty, then check structure</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> nextAction <span class="hljs-keyword">of</span> nextActions) {
      Joi.assert(nextAction, validator)
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If there is a delay, or nextActions, then an ID should be returned to allow a listener to be registered.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (delay &gt; <span class="hljs-number">0</span> || nextActions.length &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">this</span>._callDomoticAction({id, action, delay}, callback, macroId || crypto.randomBytes(<span class="hljs-number">20</span>).toString(<span class="hljs-string">'hex'</span>), ...nextActions)
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">this</span>._callDomoticAction({id, action, delay: <span class="hljs-number">0</span>}, callback)
    }
  }</div></div></div><div class="segment"><div class="comments doc-section doc-section-private"><div class="wrapper"><p><span class='doc-section-header'>Private</span></p>
<p>Subcall of callDomoticAction() to allow recursive call, and to keep unique macro ID over all the macro steps.</p>
<p>Parameters:</p>
<ul>
<li><p><strong>info is optional and must be an Object.</strong><br/>(Information to trigger the event)</p>
<ul>
<li><p><strong>info.id must be an integer.</strong><br/>(The unique ID of the domotic switch to play action against)</p>
</li>
<li><p><strong>info.action must be a string.</strong><br/>(The action to trigger. Can be on or off)</p>
</li>
<li><p><strong>info.delay must be an integer.</strong><br/>(The delay (optional) to wait before triggering the action. If &gt; 0 then the method will callback just after scheduling of the action)</p>
</li>
</ul>
</li>
<li><p><strong>callback must be a function.</strong><br/>(The function to call with all data, depending on the step of the action macro: in the simplest case (one action, no delay), then the result of the call to Myfox. In other cases, an ID to follow with a macro listener The callback parameters must follows the same signature as a macro listener (see addMacroListener() method))</p>
</li>
<li><p><strong>macroId is optional and must be a string.</strong><br/>(Optional ID to keep track of the action if multiple steps or delay is provided.)</p>
</li>
<li><p><strong>info must be an Array of Objects.</strong><br/>([]] The next actions informations, like the first param)</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">  _callDomoticAction ({id, action, delay = <span class="hljs-number">0</span>}, callback, macroId = <span class="hljs-literal">null</span>, ...nextActions) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Call Api for first action (or schedule it if delayed), THEN schedule next.
If scheduled, cannot return the state in the callback: will return an ID to register a listener.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (delay &gt; <span class="hljs-number">0</span>) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Delayed case: returns directly with an ID, and schedules calling itself for later.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">const</span> that = <span class="hljs-keyword">this</span>
      setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        that._callDomoticAction({id, action, delay: <span class="hljs-number">0</span>}, that.notifyMacroListeners.bind(that), macroId, ...nextActions)
      }, delay)
      callback(<span class="hljs-literal">null</span>, { id: macroId, state: <span class="hljs-string">'delayed'</span>, remaining: nextActions.length })
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">let</span> url = config.get(<span class="hljs-string">'myfox-wrapper-api.html.myfox.paths.domotic_action'</span>).replace(<span class="hljs-string">'{action}'</span>, action).replace(<span class="hljs-string">'{id}'</span>, id)
      <span class="hljs-keyword">this</span>.callApi(url, <span class="hljs-string">'POST'</span>, simpleCodeActionParser(<span class="hljs-keyword">this</span>), {}, {}, {})
        .then((parser) =&gt; {
          <span class="hljs-keyword">if</span> (parser.status === <span class="hljs-string">'ok'</span>) {
            <span class="hljs-keyword">const</span> domotic = cloneDeep(<span class="hljs-keyword">this</span>.persistentStates.domotic.value)
            domotic[id].supposedState = (action === <span class="hljs-string">'on'</span>) ? <span class="hljs-string">'1'</span> : <span class="hljs-string">'0'</span>
            <span class="hljs-keyword">this</span>.persistentStates.domotic.push(domotic)
          }
          callback(<span class="hljs-literal">null</span>, {
            id: macroId,
            data: parser.data,
            state: (nextActions.length &gt; <span class="hljs-number">0</span>) ? <span class="hljs-string">'progress'</span> : <span class="hljs-string">'finished'</span>,
            remaining: nextActions.length
          })</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If still some steps after, then call in recursive way</p></div></div><div class="code"><div class="wrapper">          <span class="hljs-keyword">if</span> (nextActions.length &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">let</span> nextAction = nextActions.shift()
            <span class="hljs-keyword">this</span>._callDomoticAction(nextAction, <span class="hljs-keyword">this</span>.notifyMacroListeners.bind(<span class="hljs-keyword">this</span>), macroId, ...nextActions)
          }
        })
        .catch((err) =&gt; {
          <span class="hljs-built_in">console</span>.error(err)
          callback(err)
        })
    }
  }</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Calls heating 4 orders piloted (/widget/{siteId}/heating/{action}/{id}) to turn on/eco/frost/off a heating.</p>
<p>Parameters:</p>
<ul>
<li><p><strong>info is optional and must be an Object.</strong><br/>(Information to trigger the event)</p>
<ul>
<li><p><strong>info.id must be an integer.</strong><br/>(The unique ID of the heating pilot to play action against)</p>
</li>
<li><p><strong>info.action must be a string.</strong><br/>(The action to trigger. Can be on, eco, frost or off)</p>
</li>
<li><p><strong>info.delay must be an integer.</strong><br/>(The delay (optional) to wait before triggering the action. If &gt; 0 then the method will callback just after scheduling of the action)</p>
</li>
</ul>
</li>
<li><p><strong>callback must be a function.</strong><br/>(The function to call with all data, depending on the step of the action macro: in the simplest case (one action, no delay), then the result of the call to Myfox. In other cases, an ID to follow with a macro listener The callback parameters must follows the same signature as a macro listener (see addMacroListener() method))</p>
</li>
<li><p><strong>macroId is optional and must be a string.</strong><br/>(Optional ID to keep track of the action if multiple steps or delay is provided.)</p>
</li>
<li><p><strong>info must be an Array of Objects.</strong><br/>([]] The next actions informations, like the first param)</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">  callHeatingAction ({id, action, delay = <span class="hljs-number">0</span>}, callback, macroId = <span class="hljs-literal">undefined</span>, ...nextActions) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Validation of parameters</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">const</span> validator = Joi.object({
      id: Joi.number().integer().required().positive(),
      action: Joi.string().required().valid([<span class="hljs-string">'on'</span>, <span class="hljs-string">'eco'</span>, <span class="hljs-string">'frost'</span>, <span class="hljs-string">'off'</span>]),
      delay: Joi.number().integer().min(<span class="hljs-number">0</span>).optional().default(<span class="hljs-number">0</span>)
    })

    Joi.assert({id, action, delay}, validator)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If nextActions not empty, then check structure</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> nextAction <span class="hljs-keyword">of</span> nextActions) {
      Joi.assert(nextAction, validator)
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If there is a delay, or nextActions, then an ID should be returned to allow a listener to be registered.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (delay &gt; <span class="hljs-number">0</span> || nextActions.length &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">this</span>._callHeatingAction({id, action, delay}, callback, macroId || crypto.randomBytes(<span class="hljs-number">20</span>).toString(<span class="hljs-string">'hex'</span>), ...nextActions)
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">this</span>._callHeatingAction({id, action, delay: <span class="hljs-number">0</span>}, callback)
    }
  }</div></div></div><div class="segment"><div class="comments doc-section doc-section-private"><div class="wrapper"><p><span class='doc-section-header'>Private</span></p>
<p>Subcall of callHeatingAction() to allow recursive call, and to keep unique macro ID over all the macro steps.</p>
<p>Parameters:</p>
<ul>
<li><p><strong>info is optional and must be an Object.</strong><br/>(Information to trigger the event)</p>
<ul>
<li><p><strong>info.id must be an integer.</strong><br/>(The unique ID of the heating pilot to play action against)</p>
</li>
<li><p><strong>info.action must be a string.</strong><br/>(The action to trigger. Can be on, eco, frost or off)</p>
</li>
<li><p><strong>info.delay must be an integer.</strong><br/>(The delay (optional) to wait before triggering the action. If &gt; 0 then the method will callback just after scheduling of the action)</p>
</li>
</ul>
</li>
<li><p><strong>callback must be a function.</strong><br/>(The function to call with all data, depending on the step of the action macro: in the simplest case (one action, no delay), then the result of the call to Myfox. In other cases, an ID to follow with a macro listener The callback parameters must follows the same signature as a macro listener (see addMacroListener() method))</p>
</li>
<li><p><strong>macroId is optional and must be a string.</strong><br/>(Optional ID to keep track of the action if multiple steps or delay is provided.)</p>
</li>
<li><p><strong>info must be an Array of Objects.</strong><br/>([]] The next actions informations, like the first param)</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">  _callHeatingAction ({id, action, delay = <span class="hljs-number">0</span>}, callback, macroId = <span class="hljs-literal">null</span>, ...nextActions) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Call Api for first action (or schedule it if delayed), THEN schedule next.
If scheduled, cannot return the state in the callback: will return an ID to register a listener.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">if</span> (delay &gt; <span class="hljs-number">0</span>) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Delayed case: returns directly with an ID, and schedules calling itself for later.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">const</span> that = <span class="hljs-keyword">this</span>
      setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        that._callHeatingAction({id, action, delay: <span class="hljs-number">0</span>}, that.notifyMacroListeners.bind(that), macroId, ...nextActions)
      }, delay)
      callback(<span class="hljs-literal">null</span>, { id: macroId, state: <span class="hljs-string">'delayed'</span>, remaining: nextActions.length })
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">let</span> url = config.get(<span class="hljs-string">'myfox-wrapper-api.html.myfox.paths.heating_action'</span>).replace(<span class="hljs-string">'{action}'</span>, action).replace(<span class="hljs-string">'{id}'</span>, id)
      <span class="hljs-keyword">this</span>.callApi(url, <span class="hljs-string">'POST'</span>, simpleCodeActionParser(<span class="hljs-keyword">this</span>), {}, {}, {})
        .then((parser) =&gt; {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If action succeed, then must update persistentStates</p></div></div><div class="code"><div class="wrapper">          <span class="hljs-keyword">if</span> (parser.status === <span class="hljs-string">'ok'</span>) {
            <span class="hljs-keyword">const</span> heat = cloneDeep(<span class="hljs-keyword">this</span>.persistentStates.heat.value)
            heat[id].state = action
            <span class="hljs-keyword">this</span>.persistentStates.heat.push(heat)
          }
          callback(<span class="hljs-literal">null</span>, {
            id: macroId,
            data: parser.data,
            state: (nextActions.length &gt; <span class="hljs-number">0</span>) ? <span class="hljs-string">'progress'</span> : <span class="hljs-string">'finished'</span>,
            remaining: nextActions.length
          })</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If still some steps after, then call in recursive way</p></div></div><div class="code"><div class="wrapper">          <span class="hljs-keyword">if</span> (nextActions.length &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">let</span> nextAction = nextActions.shift()
            <span class="hljs-keyword">this</span>._callHeatingAction(nextAction, <span class="hljs-keyword">this</span>.notifyMacroListeners.bind(<span class="hljs-keyword">this</span>), macroId, ...nextActions)
          }
        })
        .catch((err) =&gt; {
          <span class="hljs-built_in">console</span>.error(err)
          callback(err)
        })
    }
  }</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Modifies the alarm level (off, half, on).</p>
<p>Parameters:</p>
<ul>
<li><p><strong>info is optional and must be an Object.</strong><br/>(Information to trigger the event.)</p>
<ul>
<li><p><strong>info.action must be a string.</strong><br/>(The level to trigger. Can be on, half or off.)</p>
</li>
<li><p><strong>info.password must be a string.</strong><br/>(The password, as for authentication process, only if the alarm level must be off or half.)</p>
</li>
</ul>
</li>
<li><p><strong>callback must be a function.</strong><br/>(The function to call with all data, depending on the step of the action macro: in the simplest case (one action, no delay), then the result of the call to Myfox. In other cases, an ID to follow with a macro listener The callback parameters must follows the same signature as a macro listener (see addMacroListener() method).)</p>
</li>
<li><p><strong>macroId is optional and must be a string.</strong><br/>(Optional ID to keep track of the action if multiple steps or delay is provided.)</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">  callAlarmLevelAction ({action, password = <span class="hljs-literal">undefined</span>}, callback, macroId = <span class="hljs-literal">undefined</span>) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Validation of parameters</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">const</span> validator = Joi.object({
      action: Joi.string().required().valid([<span class="hljs-string">'on'</span>, <span class="hljs-string">'half'</span>, <span class="hljs-string">'off'</span>])
    })
    Joi.assert({action}, validator)

    <span class="hljs-keyword">if</span> (password || action === <span class="hljs-string">'off'</span> || action === <span class="hljs-string">'half'</span>) {
      <span class="hljs-keyword">if</span> (!password || <span class="hljs-keyword">this</span>.accountCredentials.password !== password) {
        <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'Given password does not match the one used for authentication.'</span>)
        <span class="hljs-keyword">return</span> callback(<span class="hljs-string">'Given password does not match the one used for authentication.'</span>)
      }
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Build macroId only if a delay or complex steps are added.
macroId = macroId || crypto.randomBytes(20).toString(&#39;hex&#39;)</p></div></div><div class="code"><div class="wrapper">    macroId = <span class="hljs-literal">null</span>
    <span class="hljs-keyword">const</span> actionLevel = action === <span class="hljs-string">'off'</span> ? <span class="hljs-number">1</span> : (action === <span class="hljs-string">'half'</span> ? <span class="hljs-number">2</span> : (action === <span class="hljs-string">'on'</span> ? <span class="hljs-number">4</span> : -<span class="hljs-number">1</span>))
    <span class="hljs-keyword">let</span> url = config.get(<span class="hljs-string">'myfox-wrapper-api.html.myfox.paths.alarm_action'</span>).replace(<span class="hljs-string">'{level}'</span>, actionLevel)

    <span class="hljs-keyword">this</span>.callApi(url, <span class="hljs-string">'GET'</span>, simpleCodeActionParser(<span class="hljs-keyword">this</span>), {}, {}, {})
      .then((parser) =&gt; {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If action succeed, then must update persistentStates</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">if</span> (parser.status === <span class="hljs-string">'ok'</span>) {
          <span class="hljs-keyword">this</span>.persistentStates.alarm.push(action)
        }
        callback(<span class="hljs-literal">null</span>, {
          id: macroId,
          data: parser.data,
          state: <span class="hljs-string">'finished'</span>,
          remaining: <span class="hljs-number">0</span>
        })
      })
      .catch((err) =&gt; {
        <span class="hljs-built_in">console</span>.error(err)
        callback(err)
      })
  }</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Uses edition mode to inspect a scenario and get its temperature settings (HTML strategy only)</p>
<p>Parameters:</p>
<ul>
<li><p><strong>scenarioId must be a string.</strong><br/>(The ID of the scenario to inspect. The scenario edition will not modify any parameter.)</p>
</li>
<li><p><strong>callback must be a function.</strong><br/>(The function to call with all data.)</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">  inspectScenarioTemperatureSettings (scenarioId, callback) {
    <span class="hljs-keyword">const</span> url1 = config.get(<span class="hljs-string">'myfox-wrapper-api.html.myfox.paths.scenario_edition_temp_1'</span>).replace(<span class="hljs-string">'{scenarioId}'</span>, scenarioId)
    <span class="hljs-keyword">const</span> url2 = config.get(<span class="hljs-string">'myfox-wrapper-api.html.myfox.paths.scenario_edition_temp_2'</span>).replace(<span class="hljs-string">'{scenarioId}'</span>, scenarioId)
    <span class="hljs-keyword">const</span> url3 = config.get(<span class="hljs-string">'myfox-wrapper-api.html.myfox.paths.scenario_edition_temp_3'</span>).replace(<span class="hljs-string">'{scenarioId}'</span>, scenarioId)
    <span class="hljs-keyword">this</span>.callApi(url1, <span class="hljs-string">'GET'</span>, step1Parser(<span class="hljs-keyword">this</span>), {}, {}, {})
      .then((parser1) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.callApi(url2, <span class="hljs-string">'POST'</span>, step2Parser(<span class="hljs-keyword">this</span>), {}, {}, parser1.nextPayload)
      })
      .then((parser2) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.callApi(url3, <span class="hljs-string">'POST'</span>, step3TempInspectionParser(<span class="hljs-keyword">this</span>), {}, {}, parser2.nextPayload)
      })
      .then((parser3) =&gt; {
        callback(<span class="hljs-literal">null</span>, parser3.data)
      })
      .catch((err) =&gt; {
        <span class="hljs-built_in">console</span>.error(err)
        callback(err)
      })
  }</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Uses edition mode to inspect and modify a scenario, in order to change temperature conditions values (HTML strategy only)</p>
<p>The temperature conditions are hard coded and supports 3 conditions, described by their HTML names here:</p>
<ul>
<li>trigger_4: the main trigger of the scenario: you can find it in the tabs of events that will execute the scenario</li>
<li>condition_4_1: the first condition that you can add after the main trigger: you can find it in a list of checkable conditions.</li>
<li>condition_4_2: the second sub-condition that appears when the condition_4_1 is already checked and set.</li>
</ul>
<p>Parameters:</p>
<ul>
<li><p><strong>scenarioId must be a string.</strong><br/>(The ID of the scenario to modify. The scenario edition WILL modify parameters depending on the settings given.)</p>
</li>
<li><p><strong>settings must be an Array of Objects.</strong><br/>(An array of temperature values to modify, associated to the conditions to look in.)</p>
</li>
<li><p><strong>callback must be a function.</strong><br/>(The function to call with all data.)</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">  updateScenarioTemperatureSettings (scenarioId, settings, callback) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Validation of parameters</p></div></div><div class="code"><div class="wrapper">    Joi.assert(scenarioId, Joi.string().required())
    <span class="hljs-keyword">const</span> validator = Joi.array().items(Joi.object({
      toTemperature: Joi.number(),
      controls: Joi.array().items(Joi.object({
        condition: Joi.string().required().valid([<span class="hljs-string">'trigger_4'</span>, <span class="hljs-string">'condition_4_1'</span>, <span class="hljs-string">'condition_4_2'</span>]),
        deviceSlaveId: Joi.string().required(),
        checked: Joi.boolean().optional()
      }).unknown())
    }))
    Joi.assert(settings, validator)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Launch edition posts</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">const</span> url1 = config.get(<span class="hljs-string">'myfox-wrapper-api.html.myfox.paths.scenario_edition_temp_1'</span>).replace(<span class="hljs-string">'{scenarioId}'</span>, scenarioId)
    <span class="hljs-keyword">const</span> url2 = config.get(<span class="hljs-string">'myfox-wrapper-api.html.myfox.paths.scenario_edition_temp_2'</span>).replace(<span class="hljs-string">'{scenarioId}'</span>, scenarioId)
    <span class="hljs-keyword">const</span> url3 = config.get(<span class="hljs-string">'myfox-wrapper-api.html.myfox.paths.scenario_edition_temp_3'</span>).replace(<span class="hljs-string">'{scenarioId}'</span>, scenarioId)
    <span class="hljs-keyword">const</span> url4 = config.get(<span class="hljs-string">'myfox-wrapper-api.html.myfox.paths.scenario_edition_temp_4'</span>).replace(<span class="hljs-string">'{scenarioId}'</span>, scenarioId)
    <span class="hljs-keyword">const</span> url5 = config.get(<span class="hljs-string">'myfox-wrapper-api.html.myfox.paths.scenario_edition_temp_5'</span>).replace(<span class="hljs-string">'{scenarioId}'</span>, scenarioId)
    <span class="hljs-keyword">this</span>.callApi(url1, <span class="hljs-string">'GET'</span>, step1Parser(<span class="hljs-keyword">this</span>), {}, {}, {})
      .then((parser1) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.callApi(url2, <span class="hljs-string">'POST'</span>, step2Parser(<span class="hljs-keyword">this</span>), {}, {}, parser1.nextPayload)
      })
      .then((parser2) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.callApi(url3, <span class="hljs-string">'POST'</span>, step3TempModificationParser(<span class="hljs-keyword">this</span>), {}, {}, parser2.nextPayload)
      })
      .then((parser3) =&gt; {
        <span class="hljs-keyword">const</span> fixedPayload = step3TempFixer(parser3.nextPayload, settings)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.callApi(url4, <span class="hljs-string">'POST'</span>, step4Parser(<span class="hljs-keyword">this</span>), {}, {}, fixedPayload)
      })
      .then((parser4) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.callApi(url5, <span class="hljs-string">'POST'</span>, step5Parser(<span class="hljs-keyword">this</span>), {}, {}, parser4.nextPayload)
      })
      .then((parser5) =&gt; {
        callback(<span class="hljs-literal">null</span>, parser5.data)
      })
      .catch((err) =&gt; {
        <span class="hljs-built_in">console</span>.error(err)
        callback(err)
      })
  }
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>exports</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myfoxWrapperApiHtml</span> (<span class="hljs-params">options, fallbackApi, accountCredentials</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyfoxWrapperApiHtml(options, fallbackApi, accountCredentials)
}</div></div></div></div></body></html>